pfem_all <- get_pfem( '
F M
Adult 109 185
Juvenile 188 302
Sub-Adult 41 80
')
avail <- '
Year Juvenile Sub-adult Adult Total
2015 68 (33) 10 (3) 27 (8) 105
2016 115 (85) 32 (22) 56 (38) 203
2017 77 (11) 26 (17) 55 (12) 158
2018 79 2 31 112
2019 77 9 64 150
'
# Strip trailing/leading spaces; all mid-spaces to 1
avail <- strsplit( avail, '\n')[[1]]
avail <- gsub( '  +', '', gsub( ' +$', '', gsub( '^ +', '', avail)))
avail <- avail[ nzchar( avail)] # drop empty lines
avail <- avail[-1]
years <- as.integer( sub( ' .*', '', avail))
# Remove year and total
avail_nums <- sub( '^[0-9]+ +', '', avail)
# Insert (0) if missing
avail_nums <- gsub( '(?<=[0-9]) (?![(])', ' (0) ', avail_nums, perl=TRUE)
# Drop everything between parens:
avail_all <- gsub( '[(][^)]*[)]', '', avail_nums)
# ... and drop total
avail_all <- sub( ' +[0-9]+ *$', '', avail_all)
# Keep only things between parens--- bit lazy:
avail_now <- gsub( '(?<![(0-9])[0-9]+ *', '', avail_nums, perl=T)
avail_now <- gsub( '[)(]', '', avail_now)
get_avail <- function( nums) {
nums <- do.call( 'rbind', strsplit( nums, ' +'))
storage.mode( nums) <- 'integer'
offarray( nums, first=c( min( years), 1), last=c( max( years), 3), dimnames=list( NULL, cq( J, S, A)))
}
avail_all <- get_avail( avail_all)
avail_now <- get_avail( avail_now)
returnList( pfem_now, pfem_all, avail_now, avail_all)
}))
STAGES <- cq( J, S, A)
STAGES
if( (nsamp %is.not.an% 'offarray') ||
!my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
!is.numeric( nsamp)) {
stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
paste( STAGES, collapse=',')))
}
ppois
?ppois
## Checks on what we have now: say 2--4 MSPs, and 0 MOPs
f_now_500_08 <- fbatto( avail_now, pfem_now, 500, 0.8)
## The main function
fbatto <- function( nsamp, pfemale, nfem, sfem) {
STAGES <- cq( J, S, A)
if( (nsamp %is.not.an% 'offarray') ||
!my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
!is.numeric( nsamp)) {
stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
paste( STAGES, collapse=',')))
}
nsamp <- nsamp[, STAGES] # ensure order
if( !my.all.equal( sort( names( pfemale)), sort( STAGES)) ||
!is.numeric( pfemale)) {
stop( sprintf( "'pfemale' must be numeric vector with names %s",
paste( STAGES, collapse=',')))
}
pfemale <- pfemale[ STAGES] # ensure order
Ymin <- firstel( nsamp, 1)
Ymax <- lastel( nsamp, 1)
A <- c( J=1, S=2, A=NA)
YEARS <- Ymin:Ymax # of sampling
extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, {
B1 <- Y1 - A[ C1]
B2 <- Y2 - A[ C2]
dB <- B2 - B1
# HSP/FSP: older must be first. Use all comparisons for ease, but younger-older doesn't count!
Pr_MSP    <- (sfem^dB / nfem) * (dB>0)
ncomp_MSP <- nsamp[ Y1, C1] * nsamp[ Y2, C2]
E_MSP     <- ncomp_MSP * Pr_MSP
# MOP: mother must be first. OMP doesn't count!
# Also, don't use if #1 is adult and sampled *after* #2 is born
# because don't know if #1 was mature at B2
# If #1 is adult and sampled before #2, that's usable
# Won't know B1 if #1 is adult
# NB: in autoloop, you need to use "*" to mean "indicator" (ie "when"). Don't use "&"...
Pr_MOP <- (C2 != 'A') *
( (B2 >= B1+2) |
((C1=='A' ) & (Y1 <= B2))
) *
ifelse( Y1 < B2, sfem^(B2-Y1), 1) /
nfem
ncomp_MOP <- pfemale[ C1] * nsamp[ Y1, C1] * nsamp[ Y2, C2]
E_MOP <- ncomp_MOP * Pr_MOP
returnList( E_MSP, E_MOP, ncomp_MSP, Pr_MSP, ncomp_MOP, Pr_MOP, dB)
}))
# Some unusables will have NA--- means 0
E_MSP[ VECSUB=is.na( E_MSP)] <- 0
E_MOP[ VECSUB=is.na( E_MOP)] <- 0
# I'm too lazy to work out valid range of dY. But, we have computers...
extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, dB=0:max( dB, na.rm=TRUE), {
B1 <- Y1-A[ C1]
B2 <- Y2-A[ C2]
actual_dB <- B2 - B1
E_MSP_DYY <- E_MSP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
E_MOP_DYY <- E_MOP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
returnList( E_MSP_DYY, E_MOP_DYY)
}))
E_MSP_DYY[ VECSUB=is.na( E_MSP_DYY)] <- 0
E_MOP_DYY[ VECSUB=is.na( E_MOP_DYY)] <- 0
E_MSP_dB <- sumover( E_MSP_DYY, cq( Y1, C1, Y2, C2))
E_MOP_dB <- sumover( E_MOP_DYY, cq( Y1, C1, Y2, C2))
E_MSP_tot <- sum( E_MSP_dB)
E_MOP_tot <- sum( E_MOP_dB)
# Add the arguments as attributes, but don't print them by default
args <- mget( names( formals( sys.function())))
args <- FOR( args, { class(.) <- 'nullprint'; .})
listo <- returnList( E_MSP_tot, E_MOP_tot, E_MSP_dB, E_MOP_dB)
attributes( listo) <- c( attributes( listo), args)
return( listo)
}
## Checks on what we have now: say 2--4 MSPs, and 0 MOPs
f_now_500_08 <- fbatto( avail_now, pfem_now, 500, 0.8)
f_now_500_08
# We can do this over a whole bunch more things to see
# ----------------------------------------------------
samps <- seq(500, 10000, 250)
samps
surv    <- seq(0.5, 0.95, 0.05)
surv
rep(samp.sz, length(surv))
# We can do this over a whole bunch more things to see
# ----------------------------------------------------
samp.sz <- seq(500, 10000, 250)
surv    <- seq(0.5, 0.95, 0.05)
rep(samp.sz, length(surv))
cbind(rep(samp.sz, length(surv), rep(surv, each = length(samp.sz))
cbind(rep(samp.sz, length(surv), rep(surv, each = length(samp.sz)))
cbind(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)))
data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz))), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)))
rep(surv, each = length(samp.sz))
rep(samp.sz, length(surv))
data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
seq(1, dim(fbatto.res)[1])
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
dim(fbatto.res)[1]
avail_now
pfem_now
i = 1
fbatto.res.i <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res.i
fbatto.res[i, 1]
fbatto.res[i, 2]
fbatto.resp[i, 3] <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 3] <- fbatto.res.i$E_MSP_tot
fbatto.res
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
}
fbatto.res
which(fbatto.res$pois1 > 0.025 & fbatto.res$pois1 < 0.975)
which(fbatto.res$pois1 > 0.025 | fbatto.res$pois1 < 0.975)
fbatto.res$pois1
which(fbatto.res$pois1 > 0.025 & fbatto.res$pois1 < 0.975)
fbatto.res[which(fbatto.res$pois1 > 0.025 & fbatto.res$pois1 < 0.975), ]
fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ]
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 2)
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
avail_now
psamp <- avail_now
psamp
pfem_now
pfemale <- pfem_now
pfemale
STAGES <- cq( J, S, A)
if( (nsamp %is.not.an% 'offarray') ||
!my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
!is.numeric( nsamp)) {
stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
paste( STAGES, collapse=',')))
}
nsamp <- psamp
STAGES <- cq( J, S, A)
if( (nsamp %is.not.an% 'offarray') ||
!my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
!is.numeric( nsamp)) {
stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
paste( STAGES, collapse=',')))
}
nsamp <- nsamp[, STAGES] # ensure order
nsamp
class(nsamp)
my.all.equal
sort( names( pfemale))
sort( STAGES)
is.numeric( pfemale)
pfemale <- pfemale[ STAGES] # ensure order
pfemale
Ymin <- firstel( nsamp, 1)
Ymin
Ymax <- lastel( nsamp, 1)
Ymax
A <- c( J=1, S=2, A=NA)
A
YEARS <- Ymin:Ymax # of sampling
YEARS
YEARS
Y1=YEARS
C1=STAGES
C1
Y2=YEARS
C2=STAGES
C2
A[ C1]
A[ C2]
B1 <- Y1 - A[ C1]
B2 <- Y2 - A[ C2]
Y1
Y2
B1
B2
C1
C1="J"
C2="J"
B1 <- Y1 - A[ C1]
B2 <- Y2 - A[ C2]
B1
B2
dB <- B2 - B1
dB
sfem
nfem = 3500
sfem = 0.8
nfem
nsamp
Y1
nsamp[ Y1, C1]
nsamp[ Y2, C2]
ncomp_MSP <- nsamp[ Y1, C1] * nsamp[ Y2, C2]
ncomp_MSP
E_MSP     <- ncomp_MSP * Pr_MSP
Pr_MSP    <- (sfem^dB / nfem) * (dB>0)
ncomp_MSP <- nsamp[ Y1, C1] * nsamp[ Y2, C2]
E_MSP     <- ncomp_MSP * Pr_MSP
E_MSP
Pr_MSP
sfem
nfem
dB
pfemale
pfem_now
sex
109 + 185 + 188 + 302
15 + 43
51 + 70
13 + 28
121 + 41 + 58
109 + 185 + 188 + 302 + 41  + 80
pfem_all
pfem_now
sum(pfem_now)
sum(pfem_all)
pfem_now
pfem_all
109/185
1-0.58
109/(109+185)
pfem_now
round(pfem_now, 3)
pfem_all
round(pfem_all, 3)
0.8/1000 * 1000 +
0.8^2/1000 * 2000 +
0.8^3/1000 * 3000 +
0.8^4/1000 * 2000 +
0.8^5/1000 * 1000
fbatto.res
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
fbatto( avail_all, pfem_all, 2000, 0.8)$E_MSP_dB
# If you take survival=0.8, then numbers generally increase, making it easier to tell things apart.
# Base case: 1000 female adults, survival 0.8:
fbatto( avail_all, pfem_all, 1000, 0.8)
fbatto( avail_all, pfem_all, 500, 0.5)
fbatto( avail_all, pfem_all, 500, 0.5)$E_MSP_tot
fbatto( avail_all, pfem_all, 500, 0.5)$E_MOP_tot
fbatto.res.i
fbatto.res
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0,
exp.mop = 0, exp.tot = 0)
fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot
fbatto.res.prosp[i, 1] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.i
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
fbatto.res.prosp[i, 1] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.prosp[i, 2] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
fbatto.res.prosp[i, 3] <- fbatto.res.prosp[i, 1] + fbatto.res.prosp[i, 2]
}
fbatto.res.prosp
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0,
exp.mop = 0, exp.tot = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
fbatto.res.prosp[i, 3] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.prosp[i, 4] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
fbatto.res.prosp[i, 5] <- fbatto.res.prosp[i, 1] + fbatto.res.prosp[i, 2]
}
fbatto.res.prosp
fbatto.res.prosp[, 5] <- fbatto.res.prosp[, 3] + fbatto.res.prosp[, 4]
fbatto.res.prosp[, 5]
fbatto.res.prosp
i=500
j=0.5
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 1] == j), ]
i=500
j=0.5
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=3000
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=6000
j=0.5
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=500
j=0.6
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=3500
j=0.6
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=7250
j=0.6
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
j=0.7
i=500
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
j=0.8
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=750
j=0.8
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=1000
j=0.95
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=11000
j=0.95
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=10000
j=0.95
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
i=7000
j=0.95
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]
fbatto.res.prosp
which(fbatto.res.prosp[, 6] > 50)
fbatto.res.prosp[, 6]
fbatto.res.prosp
which(fbatto.res.prosp[, 5] > 50)
fbatto.res.prosp[which(fbatto.res.prosp[, 5] > 50), ]
good.scen <- fbatto.res.prosp[which(fbatto.res.prosp[, 5] > 50), ]
dim(good.scen)
good.scen <- fbatto.res.prosp[which(fbatto.res.prosp[, 5] > 75), ]
dim(good.scen)
good.scen
good.scen <- fbatto.res.prosp[which(fbatto.res.prosp[, 5] > 75), ]
dim(good.scen)
good.scen
good.scen[, c(1, 2)] <- good.scen[, c(2, 1)]
kable(good.scen)
library(knitr)
kable(good.scen, type = "latex")
?kable
kable(good.scen, format = "latex")
kable(good.scen, format = "latex", row.names = F)
## The main function
fbatto <- function( nsamp, pfemale, nfem, sfem) {
STAGES <- cq( J, S, A)
if( (nsamp %is.not.an% 'offarray') ||
!my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
!is.numeric( nsamp)) {
stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
paste( STAGES, collapse=',')))
}
nsamp <- nsamp[, STAGES] # ensure order
if( !my.all.equal( sort( names( pfemale)), sort( STAGES)) ||
!is.numeric( pfemale)) {
stop( sprintf( "'pfemale' must be numeric vector with names %s",
paste( STAGES, collapse=',')))
}
pfemale <- pfemale[ STAGES] # ensure order
Ymin <- firstel( nsamp, 1)
Ymax <- lastel( nsamp, 1)
A <- c( J=1, S=2, A=NA)
YEARS <- Ymin:Ymax # of sampling
extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, {
B1 <- Y1 - A[ C1]
B2 <- Y2 - A[ C2]
dB <- B2 - B1
# HSP/FSP: older must be first. Use all comparisons for ease, but younger-older doesn't count!
#Pr_MSP    <- (sfem^dB / nfem) * (dB>0)
Pr_MSP    <- (exp(-sfem * dB) / nfem) * (dB>0)
ncomp_MSP <- nsamp[ Y1, C1] * nsamp[ Y2, C2]
E_MSP     <- ncomp_MSP * Pr_MSP
# MOP: mother must be first. OMP doesn't count!
# Also, don't use if #1 is adult and sampled *after* #2 is born
# because don't know if #1 was mature at B2
# If #1 is adult and sampled before #2, that's usable
# Won't know B1 if #1 is adult
# NB: in autoloop, you need to use "*" to mean "indicator" (ie "when"). Don't use "&"...
Pr_MOP <- (C2 != 'A') *
( (B2 >= B1+2) |
((C1=='A' ) & (Y1 <= B2))
) *
#ifelse( Y1 < B2, sfem^(B2-Y1), 1) /
ifelse( Y1 < B2, exp(-sfem*(B2-Y1)), 1) /
nfem
ncomp_MOP <- pfemale[ C1] * nsamp[ Y1, C1] * nsamp[ Y2, C2]
E_MOP <- ncomp_MOP * Pr_MOP
returnList( E_MSP, E_MOP, ncomp_MSP, Pr_MSP, ncomp_MOP, Pr_MOP, dB)
}))
# Some unusables will have NA--- means 0
E_MSP[ VECSUB=is.na( E_MSP)] <- 0
E_MOP[ VECSUB=is.na( E_MOP)] <- 0
# I'm too lazy to work out valid range of dY. But, we have computers...
extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, dB=0:max( dB, na.rm=TRUE), {
B1 <- Y1-A[ C1]
B2 <- Y2-A[ C2]
actual_dB <- B2 - B1
E_MSP_DYY <- E_MSP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
E_MOP_DYY <- E_MOP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
returnList( E_MSP_DYY, E_MOP_DYY)
}))
E_MSP_DYY[ VECSUB=is.na( E_MSP_DYY)] <- 0
E_MOP_DYY[ VECSUB=is.na( E_MOP_DYY)] <- 0
E_MSP_dB <- sumover( E_MSP_DYY, cq( Y1, C1, Y2, C2))
E_MOP_dB <- sumover( E_MOP_DYY, cq( Y1, C1, Y2, C2))
E_MSP_tot <- sum( E_MSP_dB)
E_MOP_tot <- sum( E_MOP_dB)
# Add the arguments as attributes, but don't print them by default
args <- mget( names( formals( sys.function())))
args <- FOR( args, { class(.) <- 'nullprint'; .})
listo <- returnList( E_MSP_tot, E_MOP_tot, E_MSP_dB, E_MOP_dB)
attributes( listo) <- c( attributes( listo), args)
return( listo)
}
## Checks on what we have now: say 2--4 MSPs, and 0 MOPs
f_now_500_08 <- fbatto( avail_now, pfem_now, 500, 0.3)
f_now_500_08
# Decrease the survival (to 0.5 say--- rather drastic) and you get fewer expected kin
f_now_500_05 <- fbatto( avail_now, pfem_now, 500, 0.4)
f_now_500_05
samp.sz <- seq(500, 10000, 250)
surv    <- seq(0.2, 0.95, 0.05)
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0,
exp.mop = 0, exp.tot = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
fbatto.res.prosp[i, 3] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.prosp[i, 4] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
fbatto.res.prosp[i, 5] <- fbatto.res.prosp[i, 3] + fbatto.res.prosp[i, 4]
}
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
surv    <- seq(0.2, 0.95, 0.1)
surv
surv    <- seq(0.2, 0.95, 0.1)
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0,
exp.mop = 0, exp.tot = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
fbatto.res.prosp[i, 3] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.prosp[i, 4] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
fbatto.res.prosp[i, 5] <- fbatto.res.prosp[i, 3] + fbatto.res.prosp[i, 4]
}
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
samp.sz <- seq(500, 12000, 250)
surv    <- seq(0.2, 0.95, 0.1)
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0,
exp.mop = 0, exp.tot = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
fbatto.res.prosp[i, 3] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
fbatto.res.prosp[i, 4] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
fbatto.res.prosp[i, 5] <- fbatto.res.prosp[i, 3] + fbatto.res.prosp[i, 4]
}
fbatto.res.prosp
round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
1000 * exp(-0.3)/1000 + 2000 * exp(-0.3 * 2) / 1000 + 1000 * exp(-0.3 * 3) / 1000
500 * exp(-0.3)/1000 + 1000 * exp(-0.3 * 2) / 1000 + 500 * exp(-0.3 * 3) / 1000
2000 * exp(-0.3)/1000 + 4000 * exp(-0.3 * 2) / 1000 + 2000 * exp(-0.3 * 3) / 1000
4000 * exp(-0.3)/1000 + 6000 * exp(-0.3 * 2) / 1000 + 4000 * exp(-0.3 * 3) / 1000
