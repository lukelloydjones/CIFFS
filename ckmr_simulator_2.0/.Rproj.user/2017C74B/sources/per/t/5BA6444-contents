# ---------------------------------------------
# Code to investigate how many FSPs we see and
# how many intra-cohort (Em = 0) in the we have
# The we may look at changing the simulation 
# function to look into supermales
# Author: Luke Lloyd-Jones
# Date started: 02/04/2020
# Date updated: 02/04/2020
# ---------------------------------------------
suppressPackageStartupMessages({
  library(atease)   
  library(mvbutils)
  library(dplyr)
  library(offarray)
  library(reshape)
  library(RColorBrewer)
  library(TMB)
})
# Initial pars
sim.no        <- 30   # Number of simulations 
years.samp    <- 3    # How many years do you want to sample
sam.no.py     <- 75  # How many individuals do you want to sample per year
pop.samp.dead <- 0    # 1 => Lethal sampling, 0 => mark-recapture
scen          <- 0.3  # Of the scenarios simulated, which one do you want to analayse?
# ----------------
two_or_none <- ""
apply(rep.seq, 1, function(x) pop_sample_2(sam.no.py, years.samp, scen, gens, pop.samp.dead, x, two_or_none))
# ------------------------------------------------------------------------
# Read back in the samples and compute the kin. Save each as an Rdata file
# ------------------------------------------------------------------------
make_directories("found_kin_2", "preped_data_2")
make_directories(file.path("found_kin_2", paste0("mort_", scen)))
apply(rep.seq, 1, function(x) find_kin_2(sam.no.py, years.samp, scen, x, two_or_none))
# ------------------------------------------------------------------------
# Read back in the kin sets and the pop sample and prime the combinations
# and kin for fitting
# ------------------------------------------------------------------------
make_directories(file.path("preped_data_2", paste0("mort_", scen)))
apply(rep.seq, 1, function(x) data_prep_2(sam.no.py, years.samp, scen, x, pop.samp.dead, two_or_none))
# ------------------------------------------------------------------------
# Cycle back in all the preped kin and summarise
# No. of FSPs
# Average number of HSPs matrix
# ------------------------------------------------------------------------
fsps.no   <- 0
comb_hsp <- list()
kin_mhsp  <- list()
kin_phsp  <- list()
for (repi in rep.seq)
{
  load(paste0("found_kin/mort_", scen, "/pop_samp_", repi, "_yrs_samp_",
              years.samp, "_samp_no_py_", sam.no.py, ".Rdata"))
  load(paste0("preped_data/mort_", scen, "/pop_samp_", repi, "_yrs_samp_",
              years.samp, "_samp_no_py_", sam.no.py, ".Rdata"))
  # -----------------
  # Do the TMB setup
  # -----------------
  comb_hsp[[repi]] <- as.array(com.kin$n_comp_HSP) +  as.array(com.kin$n_comp_HSP)
  kin_mhsp[[repi]] <- as.array(com.kin$n_mhsps)
  kin_phsp[[repi]] <- as.array(com.kin$n_phsps)
  fsps.no  <- fsps.no + dim(kin$fsps)[1]
}

ceiling(apply(simplify2array(comb_hsp), 1:2, mean))
ceiling(apply(simplify2array(comb_hsp), 1:2, sd))

ceiling(apply(simplify2array(kin_hsp), 1:2, mean))
ceiling(apply(simplify2array(kin_hsp), 1:2, sd))

ceiling(apply(simplify2array(kin_mhsp), 1:2, mean))
ceiling(apply(simplify2array(kin_phsp), 1:2, mean))
fsps.no / sum(apply(simplify2array(kin_hsp), 2, sum))  # One in every  500 odd.


# ------------------------------------------------
# OK now with the supermale simulator what happens
# ------------------------------------------------

mort.pars <- list(0.3) #, 0.23, 0.258, 0.30) # Increasing, stable, decreasing
# Funtion args population start size in 1978, generations and mortality parameter
start.size <- 10000
gens       <- 40
type_no <- "_3"
dir.create(file.path(paste0("populations", type_no)))
lapply(mort.pars, function(x) ciff_simulate_supermales(start.size, gens, x, 0.95, type_no)) 
# ---------------------
# Sample the population
# ---------------------
sim.no        <- 30   # Number of simulations 
years.samp    <- 5    # How many years do you want to sample
sam.no.py     <- 145  # How many individuals do you want to sample per year
pop.samp.dead <- 0    # 1 => Lethal sampling, 0 => mark-recapture
scen          <- 0.3  # Of the scenarios simulated, which one do you want to analayse?
make_directories(file.path(paste0("sampled_populations", two_or_none)))
make_directories(file.path(paste0("sampled_populations", two_or_none, "/mort_", scen)))
rep.seq <- array(seq(1, sim.no))
# Sample the populations. Warning: write data to subdirectories
two_or_none <- "_3"
apply(rep.seq, 1, function(x) pop_sample_2(sam.no.py, years.samp, scen, gens, pop.samp.dead, x, two_or_none))
# ------------------------------------------------------------------------
# Read back in the samples and compute the kin. Save each as an Rdata file
# ------------------------------------------------------------------------
make_directories(file.path(paste0("found_kin", two_or_none)))
make_directories(file.path(paste0("found_kin", two_or_none, "/mort_", scen)))
apply(rep.seq, 1, function(x) find_kin_2(sam.no.py, years.samp, scen, x, two_or_none))
# ------------------------------------------------------------------------
# Read back in the kin sets and the pop sample and prime the combinations
# and kin for fitting
# ------------------------------------------------------------------------
make_directories(file.path(paste0("preped_data", two_or_none)))
make_directories(file.path(paste0("preped_data", two_or_none, "/mort_", scen)))
#rep.seq <- rep.seq[-seq(1,6)]
apply(rep.seq, 1, function(x) data_prep_2(sam.no.py, years.samp, scen, x, pop.samp.dead, two_or_none))
# ------------------------------------------------------------------------
# Cycle back in all the preped kin and summarise
# No. of FSPs
# Average number of HSPs matrix
# ------------------------------------------------------------------------
fsps.no <- 0
comb_hsp_pat <- list()
comb_hsp_mat <- list()
kin_hsp_pat  <- list()
kin_hsp_mat  <- list()
kin_fop_pat  <- list()
kin_mop_mat  <- list()
for (repi in rep.seq)
{
  load(paste0("found_kin", two_or_none, "/mort_", scen, "/pop_samp_", repi, "_yrs_samp_",
              years.samp, "_samp_no_py_", sam.no.py, ".Rdata"))
  load(paste0("preped_data", two_or_none,"/mort_", scen, "/pop_samp_", repi, "_yrs_samp_",
              years.samp, "_samp_no_py_", sam.no.py, ".Rdata"))
  # -----------------
  # Do the TMB setup
  # -----------------
  comb_hsp_pat[[repi]] <- as.array(com.kin$n_comp_HSP) 
  comb_hsp_mat[[repi]] <- as.array(com.kin$n_comp_HSP) 
  kin_hsp_pat[[repi]]  <- as.array(com.kin$n_phsps)
  kin_hsp_mat[[repi]]  <- as.array(com.kin$n_mhsps) 
  kin_fop_pat[[repi]]  <- as.array(com.kin$n_FOP_noage)
  kin_mop_mat[[repi]]  <- as.array(com.kin$n_MOP_noage) 
  fsps.no  <- fsps.no + dim(kin$fsps)[1]
}


ceiling(apply(simplify2array(comb_hsp_pat), 1:2, mean))
ceiling(apply(simplify2array(comb_hsp_pat), 1:2, sd))

ceiling(apply(simplify2array(comb_hsp_mat), 1:2, mean))
ceiling(apply(simplify2array(comb_hsp_mat), 1:2, sd))

ceiling(apply(simplify2array(kin_hsp_pat), 1:2, mean))
ceiling(apply(simplify2array(kin_hsp_pat), 1:2, sd))

ceiling(apply(simplify2array(kin_hsp_mat), 1:2, mean))
ceiling(apply(simplify2array(kin_hsp_mat), 1:2, sd))

fsps.no / (sum(apply(simplify2array(kin_hsp_mat), 2, sum)) + 
           sum(apply(simplify2array(kin_hsp_pat), 2, sum))) # One in every  700 odd.

# How many kin do we think we will get

mean(unlist(lapply(kin_hsp_mat, sum)))
mean(unlist(lapply(kin_fop_pat, sum)))

# ===============================================
# Can we estimate the paremeters given these data
# ===============================================

par.ests <- matrix(0, nrow = sim.no, ncol = 6) # Always a six parameter model
abundance.ests2 <- matrix(0, nrow = sim.no, ncol = years.samp + 2)
abundance.ests.fem <- matrix(0, nrow = sim.no, ncol = years.samp + 2)
abundance.ests.mal <- matrix(0, nrow = sim.no, ncol = years.samp + 2)
kin.nos <- matrix(0, nrow = length(rep.seq), ncol = 2)
kin.fem <- matrix(0, nrow = length(rep.seq), ncol = 2)
kin.mal <- matrix(0, nrow = length(rep.seq), ncol = 2)
for (repi in rep.seq)
{
  print(paste0("Fitting sample ", repi))
  load(paste0("preped_data", two_or_none,"/mort_", scen, "/pop_samp_", repi, "_yrs_samp_",
              years.samp, "_samp_no_py_", sam.no.py, ".Rdata"))
  # -----------------
  # Do the TMB setup
  # -----------------
  data  <- list(comb_mop = as.array(com.kin$n_comp_MOP_noage),  kin_mop = as.array(com.kin$n_MOP_noage),
                comb_fop = as.array(com.kin$n_comp_FOP_noage),  kin_fop = as.array(com.kin$n_FOP_noage),
                comb_mhsp = as.array(com.kin$n_comp_HSP), kin_mhsp = as.array(com.kin$n_mhsps),
                comb_fhsp = as.array(com.kin$n_comp_HSP), kin_fhsp = as.array(com.kin$n_phsps),
                symin  = min(com.kin$Yad_range), symax = max(com.kin$Yad_range), 
                bymin = min(com.kin$Bju_range),  bymax = max(com.kin$Bju_range), 
                lethal = com.kin$lethal)
  ciff_nllk <- MakeADFun(data, 
                         parameters = list(N0_f = log(1000), N0_m = log(1000), Z1 = 0.4, 
                                             Z2 = 0.45,        R1 = 0.05,      R2 = 0.01),
                         DLL = "ciff_nllk")
  ciff_nllk$control <- list(REPORT=1)
  # -----------
  # Numeric fit
  # -----------
  fit1 = nlminb(ciff_nllk$par, ciff_nllk$fn, ciff_nllk$gr, 
                lower = c(1, 1, -10, -12, -10, -10), 
                upper = c(20000, 20000, 10, 10, 10, 10))
  sdreport(ciff_nllk, fit1$par)
  print(paste("SCORE SCORE SCORE SCOOOOOOORRRREEEE", ciff_nllk$gr(fit1$par))) 
  print(fit1$par)
  abundance.ests2[repi, ]    <- ciff_nllk$env$report()$N
  abundance.ests.fem[repi, ] <- ciff_nllk$env$report()$N_f
  abundance.ests.mal[repi, ] <- ciff_nllk$env$report()$N_m
  par.ests[repi, ] <- fit1$par
  print("Abundance through time")
  print(com.kin$N)
  print("No. POPs")
  print(sum(com.kin$n_MOP_noage) + sum(com.kin$n_FOP_noage))
  kin.nos[repi, 1] <- sum(com.kin$n_MOP_noage) + sum(com.kin$n_FOP_noage)
  kin.fem[repi, 1] <- sum(com.kin$n_MOP_noage)
  kin.mal[repi, 1] <- sum(com.kin$n_FOP_noage)
  print("No. HSPs")
  kin.nos[repi, 2] <- sum(com.kin$n_mhsps) + sum(com.kin$n_phsps)
  kin.fem[repi, 2] <- sum(com.kin$n_mhsps) 
  kin.mal[repi, 2] <- sum(com.kin$n_phsps)
  print(sum(com.kin$n_mhsps) + sum(com.kin$n_phsps))
  #Sys.sleep(2)
}
truth   <- get_ciff_adults(sam.no.py, years.samp, gens, scen, dim(abundance.ests2)[2], two_or_none)
colnames(abundance.ests2)    <- com.kin$years
colnames(abundance.ests.fem) <- com.kin$years
colnames(abundance.ests.mal) <- com.kin$years
plot_abundance(abundance.ests2, sam.no.py, years.samp, gens, scen, pop.samp.dead, two_or_none, 1)
colMeans(par.ests)
round(colMeans(abundance.ests2))
round(apply(abundance.ests2, 2, function(x) median(x)), 0)
round(colMeans(abundance.ests.fem))
round(apply(abundance.ests.fem, 2, function(x) median(x)), 0)
round(colMeans(abundance.ests.mal))
round(apply(abundance.ests.mal, 2, function(x) median(x)), 0)
# ---------------
# Standard errors
# ---------------
sds.N    <- apply(abundance.ests2, 2, function(x) sd(x))
sds.N_m  <- apply(abundance.ests.mal, 2, function(x) sd(x))
sds.N_f  <- apply(abundance.ests.fem, 2, function(x) sd(x))
sds.pars <- apply(par.ests, 2, function(x) sd(x))
# ---
# CVs
# ---
sds.N    / colMeans(abundance.ests2)
round(sds.N_f  / colMeans(abundance.ests.fem), 3)
sds.N_m  / colMeans(abundance.ests.mal)
sds.pars / colMeans(par.ests)
# ----------------------
# Expected number of kin
# ----------------------
colMeans(kin.nos)
colMeans(kin.mal)
colMeans(kin.fem)


0.8/1000 * 1000 +
  0.8^2/1000 * 2000 +
  0.8^3/1000 * 3000 +
  0.8^4/1000 * 2000 +
  0.8^5/1000 * 1000 
