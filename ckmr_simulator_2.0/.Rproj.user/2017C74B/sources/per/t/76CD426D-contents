library( mvbutils)
library( offarray) # I have version 1.0.119; key is to have 'autoloop' function

## Data prep: see the end of this block for what gets created
extract.named( local({
  get_pfem <- function( text){
    sex  <- read.table( textConnection( text), header=TRUE, row=1)
    pfem <- sex$F / rowSums( sex)
    names( pfem) <- substring( names( pfem), 1, 1)
    pfem <- pfem[ cq( J, S, A)]
    return( pfem)
  }
  
  pfem_now <- get_pfem( '
                        F M
                        Adult 15 43
                        Juvenile 51 70
                        Sub-Adult 13 28
                        ')
  
  pfem_all <- get_pfem( '
                        F M
                        Adult 109 185
                        Juvenile 188 302
                        Sub-Adult 41 80
                        ')
  
  avail <- '
  Year Juvenile Sub-adult Adult Total
  2015 68 (33) 10 (3) 27 (8) 105
  2016 115 (85) 32 (22) 56 (38) 203
  2017 77 (11) 26 (17) 55 (12) 158
  2018 79 2 31 112
  2019 77 9 64 150
  '
  
  # Strip trailing/leading spaces; all mid-spaces to 1
  avail <- strsplit( avail, '\n')[[1]]
  avail <- gsub( '  +', '', gsub( ' +$', '', gsub( '^ +', '', avail)))
  avail <- avail[ nzchar( avail)] # drop empty lines
  avail <- avail[-1]
  
  years <- as.integer( sub( ' .*', '', avail))
  
  # Remove year and total
  avail_nums <- sub( '^[0-9]+ +', '', avail)
  
  # Insert (0) if missing
  avail_nums <- gsub( '(?<=[0-9]) (?![(])', ' (0) ', avail_nums, perl=TRUE)
  
  # Drop everything between parens:
  avail_all <- gsub( '[(][^)]*[)]', '', avail_nums)
  # ... and drop total
  avail_all <- sub( ' +[0-9]+ *$', '', avail_all)
  
  # Keep only things between parens--- bit lazy:
  avail_now <- gsub( '(?<![(0-9])[0-9]+ *', '', avail_nums, perl=T)
  avail_now <- gsub( '[)(]', '', avail_now)
  
  get_avail <- function( nums) {
    nums <- do.call( 'rbind', strsplit( nums, ' +'))
    storage.mode( nums) <- 'integer'
    offarray( nums, first=c( min( years), 1), last=c( max( years), 3), dimnames=list( NULL, cq( J, S, A)))
  }
  
  avail_all <- get_avail( avail_all)
  avail_now <- get_avail( avail_now)
  
  returnList( pfem_now, pfem_all, avail_now, avail_all)
}))

## The main function
fbatto <- function( nsamp, pfemale, nfem, sfem) {
  STAGES <- cq( J, S, A)
  if( (nsamp %is.not.an% 'offarray') ||
      !my.all.equal( sort( dimnames( nsamp)[[2]]), sort( STAGES)) ||
      !is.numeric( nsamp)) {
    stop( sprintf( "'nsamp' must be numeric 'offarray' with Year * Class (latter %s)",
                   paste( STAGES, collapse=',')))
  }
  nsamp <- nsamp[, STAGES] # ensure order
  
  if( !my.all.equal( sort( names( pfemale)), sort( STAGES)) ||
      !is.numeric( pfemale)) {
    stop( sprintf( "'pfemale' must be numeric vector with names %s",
                   paste( STAGES, collapse=',')))
  }
  pfemale <- pfemale[ STAGES] # ensure order
  
  Ymin <- firstel( nsamp, 1)
  Ymax <- lastel( nsamp, 1)
  
  
  A <- c( J=1, S=2, A=NA)
  YEARS <- Ymin:Ymax # of sampling
  
  extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, {
    B1 <- Y1 - A[ C1]
    B2 <- Y2 - A[ C2]
    
    dB <- B2 - B1
    
    # HSP/FSP: older must be first. Use all comparisons for ease, but younger-older doesn't count!
    #Pr_MSP    <- (sfem^dB / nfem) * (dB>0)
    Pr_MSP    <- (exp(-sfem * dB) / nfem) * (dB>0)
    ncomp_MSP <- nsamp[ Y1, C1] * nsamp[ Y2, C2]
    E_MSP     <- ncomp_MSP * Pr_MSP
    
    # MOP: mother must be first. OMP doesn't count!
    # Also, don't use if #1 is adult and sampled *after* #2 is born
    # because don't know if #1 was mature at B2
    # If #1 is adult and sampled before #2, that's usable
    # Won't know B1 if #1 is adult
    
    # NB: in autoloop, you need to use "*" to mean "indicator" (ie "when"). Don't use "&"...
    Pr_MOP <- (C2 != 'A') *
      ( (B2 >= B1+2) |
          ((C1=='A' ) & (Y1 <= B2))
      ) *
      #ifelse( Y1 < B2, sfem^(B2-Y1), 1) /
      ifelse( Y1 < B2, exp(-sfem*(B2-Y1)), 1) /
      nfem
    ncomp_MOP <- pfemale[ C1] * nsamp[ Y1, C1] * nsamp[ Y2, C2]
        E_MOP <- ncomp_MOP * Pr_MOP
    returnList( E_MSP, E_MOP, ncomp_MSP, Pr_MSP, ncomp_MOP, Pr_MOP, dB)
  }))
  
  # Some unusables will have NA--- means 0
  E_MSP[ VECSUB=is.na( E_MSP)] <- 0
  E_MOP[ VECSUB=is.na( E_MOP)] <- 0
  
  # I'm too lazy to work out valid range of dY. But, we have computers...
  extract.named( autoloop( Y1=YEARS, C1=STAGES, Y2=YEARS, C2=STAGES, dB=0:max( dB, na.rm=TRUE), {
    B1 <- Y1-A[ C1]
    B2 <- Y2-A[ C2]
    actual_dB <- B2 - B1
    
    E_MSP_DYY <- E_MSP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
    E_MOP_DYY <- E_MOP[ Y1, C1, Y2, C2] * (abs( actual_dB)==dB)
    returnList( E_MSP_DYY, E_MOP_DYY)
  }))
  E_MSP_DYY[ VECSUB=is.na( E_MSP_DYY)] <- 0
  E_MOP_DYY[ VECSUB=is.na( E_MOP_DYY)] <- 0
  
  E_MSP_dB <- sumover( E_MSP_DYY, cq( Y1, C1, Y2, C2))
  E_MOP_dB <- sumover( E_MOP_DYY, cq( Y1, C1, Y2, C2))
  
  E_MSP_tot <- sum( E_MSP_dB)
  E_MOP_tot <- sum( E_MOP_dB)
  
  # Add the arguments as attributes, but don't print them by default
  args <- mget( names( formals( sys.function())))
  args <- FOR( args, { class(.) <- 'nullprint'; .})
  listo <- returnList( E_MSP_tot, E_MOP_tot, E_MSP_dB, E_MOP_dB)
  attributes( listo) <- c( attributes( listo), args)
  return( listo)
}

## Results

## Checks on what we have now: say 2--4 MSPs, and 0 MOPs
f_now_500_08 <- fbatto( avail_now, pfem_now, 500, 0.3)
# E_MSP_tot = 12.24, E_MOP_tot = 0.6
ppois( 2:4, 12.24) # [1] 0.000426 0.001903 0.006423

# Decrease the survival (to 0.5 say--- rather drastic) and you get fewer expected kin
f_now_500_05 <- fbatto( avail_now, pfem_now, 500, 0.4)
# 7.36 and 0.51
ppois( 2:4, 7.36) # [1] 0.02187 0.06315 0.13953 # so only juuuuust possible
# ... IE suggests there's more than 500 females, ie more than 1000 adults total! Otherwise we would have seen more MSPs

# At the other end, 10000 looks a bit shaky...
fbatto( avail_now, pfem_now, 10000, 0.8)
# E_MSP_tot=0.61
ppois( 2:4, 0.61) # [1] 0.9759 0.9964 0.9996
# OK, probably fewer than 10,000 females (20,000 total) then.

# But you can just-about-match the 2:4 MSPs and 0 MOPs with just-about-any abundance in-between 1000 and 20000

# Do not try to get a proper CI out of this !!! The assumptions are strong (eg no roostiness--- despite data to contrary) and...
# ... we can't check them with this few kin-pairs

## Checks on design, using ALL possible samples:
# Can we tell the diff between 1000 female adults, and 3000 ?

f_all_3000_05 <- fbatto( avail_all, pfem_all, 3000, 0.5)
# E_MSP_tot = 10.02 E_MOP_tot = 3.1

# repeat for 1000 @ 0.5: 30 and 9. You can definitely expect to distinguish 10 from 30.

# If you take survival=0.8, then numbers generally increase, making it easier to tell things apart.
# Base case: 1000 female adults, survival 0.8:
fbatto( avail_all, pfem_all, 1000, 0.8)
# 64 MSPs and 16 MOPs
# That would give a nice precise estimate
# Even more if even rarer
# Should make it easy to tell between "important" categories of rareness

# What about survival? 1000 @ 0.5 and 2000 @ 0.8 give about the same *totals* for E (30, 9) but
# slightly different patterns with birth-year-gap. MSPs more useful than MOPs because more of them.

fbatto( avail_all, pfem_all, 1000, 0.5)$E_MSP_dB
#dB
#     [0]      [1]      [2]      [3]      [4]      [5]
# 0.00000 19.98350  6.95025  2.55587  0.53625  0.02406


fbatto( avail_all, pfem_all, 2000, 0.8)$E_MSP_dB
#dB
#    [0]     [1]     [2]     [3]     [4]     [5]
# 0.0000 15.9868  8.8963  5.2344  1.7572  0.1262

# A bit different, but not enough to estimate survival precisely. Never mind eh!

# ----------------------------------------------------
# We can do this over a whole bunch more things to see
# ----------------------------------------------------
samp.sz <- seq(500, 12000, 250)
surv    <- seq(0.2, 0.95, 0.1)
fbatto.res <- data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, pois1 = 0, pois2 = 0, pois3 = 0)
fbatto.res.prosp <-  data.frame(rep(samp.sz, length(surv)), rep(surv, each = length(samp.sz)), exp.mhsp = 0, 
                                exp.mop = 0, exp.tot = 0)
for (i in seq(1, dim(fbatto.res)[1]))
{
  fbatto.res.i       <- fbatto(avail_now, pfem_now, fbatto.res[i, 1], fbatto.res[i, 2])
  fbatto.res[i, 3]   <- fbatto.res.i$E_MSP_tot
  fbatto.res[i, 4:6] <- ppois(2:4, fbatto.res.i$E_MSP_tot)
  fbatto.res.prosp[i, 3] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MSP_tot, 0)
  fbatto.res.prosp[i, 4] <- round(fbatto(avail_all, pfem_all, fbatto.res[i, 1], fbatto.res[i, 2])$E_MOP_tot, 0)
  fbatto.res.prosp[i, 5] <- fbatto.res.prosp[i, 3] + fbatto.res.prosp[i, 4]
}

round(fbatto.res[which(fbatto.res$pois1 < 0.025 | fbatto.res$pois1 > 0.975), ], 3)
fbatto.res.prosp[, 5] <- fbatto.res.prosp[, 3] + fbatto.res.prosp[, 4]
i=7000
j=0.95
fbatto.res.prosp[which(fbatto.res.prosp[, 1] == i & fbatto.res.prosp[, 2] == j), ]

good.scen <- fbatto.res.prosp[which(fbatto.res.prosp[, 5] > 75), ]
dim(good.scen)
good.scen[, c(1, 2)] <- good.scen[, c(2, 1)] 
kable(good.scen, format = "latex", row.names = F)


4000 * exp(-0.3)/1000 + 6000 * exp(-0.3 * 2) / 1000 + 4000 * exp(-0.3 * 3) / 1000
